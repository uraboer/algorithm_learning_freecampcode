1.Reverse a String：翻转字符串
先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串，结果必须得到一个字符串
资源：Global String Object，String.split()，Array.reverse()，Array.join()
方法：
function reverseString(str){
var strToArray = str.split('');
var reverseArrary = strToArray.reverse();
str = reverseArray.join('');
return str;
}

2.Factorialize a Number：计算一个整数的阶乘
如果用字母n来代表一个整数，阶乘所代表的是小于等于n的整数的阶乘。n!
方法一：利用while循环
function factorial(num){
var result=1;
while(num){
result*=num;
num--;
}
return result;
}

方法二：利用函数递归
function factorial(num){
if(num<=0){
return 1;
}else {
return num*argument.callee(num-1);
}
}

方法三：利用条件运算符
function factorial(num){
return(num<=0)?1:num*factorial(num-1);
}

3.Check for palindromes：回文算法
如果给定的字符串是回文，返回true，否则，返回false
如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome回文
资源：String.replace()，String.toLowerCase()]
思路：
1.用replace()去掉字符串中的标点符号、空格
2.将字符串全部转变为小写toLowerCase()
3.用reverse()判断回文，中间需要一个中间变量用于保存原字符串
方法：
function palindrome(str){
//边界判断
if(str.length===1){
return true;
}

str=str.toLowerCase();
str=str.replace(/[^a-z0-9]/g,"");
var temp=str.split('').reverse().join('');
return(temp==str)?true:false;
}

4.Find the longest word in a String：查找字符串中最长的一个单词
找到提供的句子中最长的单词，并计算出它的长度
资源：String.split()，String.length()
思路：
1.将字符串转化成数组对象split()
2.得到数组中每一个元素的长度
3.比较2中每个元素的长度，找到最大值的那个元素
4.将该元素输出，转化成字符串，计算其长度，并最终输出
方法：
function findLongestWord(str){
var Array=str.split(" ");//按空格分隔
var longest=0;
for(var i=0;i<Array.length;i++){
if(longest<Array[i].length){
longest=Array[i].length;
}
}
return longest;
}

5.Title Case a Sentence：首字母大写
确保字符串的每个单词首字母都大写，其余部分都小写。像"the"和"of"这样的连字符同理
资源：split()
思路：
1.将字符串转化为数组，先将所有的字符串小写
2.将数组中每个元素的第一个字母大写[0]，toUpperCase()，substring()
3.将数组转化为字符串
方法：
function titleCase(str){
str=str.toLowerCase();
var Array=str.split(" ");
for(var i=0;i<Array.length;i++){
Array[i]=Array[i}.substring(0,1).toUpperCase()+Array[i].substring(1);
}
str=Array.join(" ");
return str;
}

6.Return Largest Number in Arrays：返回数组中最大的数
右边大数组中包含了4个小数组，分别找到每个小数组的最大值，然后把它们串联起来，形成一个新数组
提示：可以用for循环来迭代数组，并通过arr[i]的方式来访问数组的每个元素
示例：[[4,5,1,3],[13,27,18,26],[32,35,37,39],[1000,1001,857,1]]，结果返回[27,5,39,1001]
思路：
1.获取大数组的每个元素（小数组）。//for循环遍历
2.对获取的小数组，每个进行排序。//sort()按字母进行排序
//将每个小数组降序排列arr[i].sort(function(a,b){return b-a;})
//sort()默认升序，a<b，返回负数，所以倒序就b-a
3.将每个小数组中最大的数取出添加到新的数组中。//arr[i][0]
4.返回新数组
方法：
function largestOfFour(arr) {
  var newArray=[];
  for(var i=0;i<arr.length;i++){
    arr[i].sort(function(a,b){return b-a;});
    newArray[i]=arr[i][0];
  }
  return newArray;
}

7.Confirm the Ending：检查字符串结尾
检查一个字符串（str）是否以指定的字符串（target）结尾
如果是，返回true，如果不是，返回false
资源：string.substr()
function confirmEnding(str,target){
return str.substr(-target.length,target.length)===target;
}
思路：
1.获得字符串最后一个字符/特定的字符。单个字符串/单个单词：最后一个字符；一句话字符串：最后一个单词
判断：
a.先将字符串转化为数组
b.如果数组中元素=1，则取最后一个字符；如果数组中元素>1，则取数组最后一个元素
2.与特定字符进行比对：相等/相同：true；不等/不同：false
3.特殊情况："He has to give me a new name" "me" ------true
方法：
//字符串长度str.length等于字符串位置str.indexOf()+字符串长度target.length;
//为避免字符串中重复的target所以应从后往前搜索lastIndexOf();
function confirmEnding(str, target) {
return (str.lastIndexOf(target)+target.length==str.length)?true:false;
}

8.Repeat a string repeat a string
重复一个指定的字符串num次，如果num是一个负数则返回一个空字符串
方法一：
function repeat(str,num){
var result="";
while(num>0){
result+=str;
num--;
}
return result;
}

方法二：
function repeat(str,num){
if(num<0){
return "";
}else{
return str.repeat(num); //repeat()的用法，这是ES6的方法
}
}

9.Truncate a string：截断一个字符串
如果字符串的长度比指定的参数num长，则把多余的部分用...来表示
切记，插入到字符串尾部的三个点号也会计入字符串的长度
但是，如果自定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度（以此为界限分类）
方法：
function truncate(str,num){
var newstr;
var strlength=str.length;
var newstrlength;
if(num>3 && strlength<=num){
newstr=str;
}else if(num>3 && strlength>num){
newstrlength=num-3;
newstr=str.slice(0,newstrlength).concat("...");
}else{
newstrlength=num;
newstr=str.slice(0,newstrlength).concat("...");
}
return newstr;
}

方法二：
function truncate(str,num){
if(str.length>num){
if(num<=3){
str=str.slice(0,num)+"...";
}else{
str=str.slice(0,num-3)+"...";
}
}
return str;//str.length<num 则显示全部
}

10.Chunky Monkey：猴子吃香蕉，分割数组
把一个数组arr按照指定的数组大小size 分割成若干个数组块
例如:chunk([1,2,3,4],2)=[[1,2],[3,4]];
chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]];
方法：
function chunk(arr, size) {
var newarr=[];
for(var i=0;i<arr.length;i=i+size){
newarr.push(arr.slice(i,i+size));
  	}
  	return newarr;
}

11.Slasher Flick：截断数组
返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始
资源：
1.slice()包含从start到end（不含）的arrayObject中的元素
2.begin必需，规定从何处开始选取。如果是负数，从数组尾部开始算起。-1，最后一个元素
3.splice()向/从数组中添加/删除项目，然后返回被删除的项目，splice() 方法会直接对数组进行修改
方法：
function slasher(arr,howMany){
if(howMany<arr.length){
arr.splice(0,howMany);
retrun arr;
}
arr=[];
return arr;
}

12.Mutations
蛤蟆可以吃队友，也可以吃对手。
如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true
举例，["hello", "Hello"]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。
["hello", "hey"]应该返回false，因为字符串"hello"并不包含字符"y"。
["Alien", "line"]应该返回true，因为"line"中所有字符都可以在"Alien"找到。
思路：
1.先分割第二个字符串为数组
2.for循环遍历数组元素与第一个字符串进行比对
3.都转化为小写，indexOf不包含的情况会返回-1；
方法：
function mutation(arr){
var arr1=arr[0].toLowerCase();
var arr2=arr[1].toLowerCase().split("");
for(var i=0;i<arr2.length;i++){
if(arr1.indexOf(arr2[i])<0){
return false;
}
}
return true;
}

13.Falsy Bouncer：真假美猴王
删除数组中的所有假值
在JavaScript中，假值有false、null、0、""、undefined、NaN
方法：
function bouncer(arr) {
return arr.filter(function(item){  //filter()过滤出所有boolean为true的
return Boolean(item);
});
}

14.Seek and Destroy：摧毁数组
实现一个摧毁函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值（其余参数长度不定）
思路：
1.因为arguments是类数组对象没有数组所具有的属性和方法，所以创建一个包含其余参数的数组
2.创建函数用indexOf()返回数组中不存在的元素
3.通过filter()来过滤掉arguments中要摧毁的元素
//在JavaScript中，arguments对象是比较特别的一个对象，实际上是当前函数的一个内置属性。arguments非常类似Array，但实际上又不是一个Array实例。
方法：
function destroyer(arr){
var args=[];   //创建包含其余参数的数组
for(var i=1;i<arguments.length;i++){
args.push(arguments[i]);
}

function filtered(ele){
return args.indexOf(ele)<0;   //返回数组args中不存在的元素
}
var newarr=arr.filter(filtered);
return newarr;
}

15.Where do I belong
先给数组排序，然后找到指定的值在数组中的位置，最后返回位置对应的索引
举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。
同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。
方法：
function where(arr,num){
arr.push(num);
arr.sort(function(a,b){
return a-b;
});
return arr.indexOf(num);
}

16.Caesars Cipher：凯撒密码
移位密码也就是密码中的字母会按照指定的数量来做移位
一个常见的案例就是ROT13密码，字母会移位13个位置。由'A' ↔ 'N', 'B' ↔ 'O'，以此类推。
写一个ROT13函数，实现输入加密字符串，输出解密字符串。
所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。
思路：
1.26个字母的unicode码在65（A）与90（Z）之间，第13位M（77）
2.将str通过.charCodeAt()转为unicode编码并放入新数组
3.其中非字母形式的字符直接放入.charAt()
4.后13位字母减去13后放入；前13位字母加上13后放入
5.通过.fromCharCode()转化为字母，将数组转化为字符串
//静态 String.fromCharCode() 方法返回使用指定的Unicode值序列创建的字符串。
//charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元
方法：
function rot13(str){
var newarr=[];
for(var i=0;i<str.length;i++){
if(str.charCodeAt(i)<65 || str.charCodeAt(i)>90){
newarr.push(str.charAt(i));
}else if(str.charCodeAt(i)>77){
newarr.push(String.fromCharCode(str.charCodeAt(i)-13));
}else{
newarr.push(String.fromCharCode(str.charCodeAt(i)+13));
}
}
return newarr.join("");
}
